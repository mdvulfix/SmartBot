// === file: websocket.js ===
// assets/websocket.js
// Полностью обновлённый файл: два режима (historical, realtime) + кнопки таймфрейма + start/end

// ========== Глобальные состояния ==========
window.ws = null;
window.isConnected = false;
window.currentSymbol = 'BTC-USDT';
window.currentTimeframe = '1H';
window.charts = null;

window._resizeObserver = null;
window._timeRangeUnsub = null;
window._reconnectTimer = null;
window._realtimeInterval = null;

// ========== Хелперы ==========
function mapTimeframeToOkxBar(tf) {
  const map = { '1m':'1m','5m':'5m','15m':'15m','1H':'1H','4H':'4H','1D':'1D' };
  return map[tf] || '1H';
}

function normalizeSymbol(raw) {
  if (!raw) return raw;
  let s = String(raw).trim();
  s = s.replace(/[\/\uFF0F\s]+/g, '-');
  s = s.replace(/[^\w\-]/g, '-');
  s = s.replace(/-+/g, '-');
  return s.toUpperCase();
}

function normalizeTimeframe(raw) {
  if (!raw) return raw;
  let t = String(raw).trim();
  const ru = {
    '1 минута':'1m','1 мин':'1m','1м':'1m',
    '5 минут':'5m','5 мин':'5m',
    '15 минут':'15m','15 мин':'15m',
    '1 час':'1H','1ч':'1H',
    '4 часа':'4H','4 ч':'4H',
    '1 день':'1D','1д':'1D'
  };
  const lower = t.toLowerCase();
  if (ru[lower]) return ru[lower];
  if (/^\d+\s*m(in(ute)?s?)?$/i.test(t)) { const num = t.match(/\d+/)[0]; return `${num}m`; }
  if (/^\d+\s*h(r|our|ours)?$/i.test(t) || /^\d+H$/i.test(t)) { const num = t.match(/\d+/)[0]; return `${num}H`; }
  if (/^\d+m$/i.test(t)) return t.toLowerCase();
  if (/^\d+h$/i.test(t)) return t.toUpperCase();
  return t;
}

function getDashRequestsPathnamePrefix() {
  try {
    const el = document.getElementById('_dash-config');
    if (!el) return '/';
    const cfg = JSON.parse(el.textContent || el.innerText || '{}');
    const prefix = cfg.requests_pathname_prefix || '/';
    let p = String(prefix);
    if (!p.startsWith('/')) p = '/' + p;
    p = p.replace(/\/+$/, '');
    return p || '/';
  } catch (e) {
    return '/';
  }
}

function readDropdownValue(elem) {
  if (!elem) return null;
  const sel = elem.querySelector('select'); if (sel && sel.value) return sel.value;
  const input = elem.querySelector('input'); if (input && input.value) return input.value;
  const dv = elem.querySelector('[data-value]')?.dataset?.value; if (dv) return dv;
  const opt = elem.querySelector('[aria-selected="true"], .is-selected, .Select-value'); if (opt) return opt.dataset?.value || opt.textContent?.trim() || null;
  const txt = elem.textContent?.trim(); return txt || null;
}

function updateStatus(msg) {
  const el = document.getElementById('status');
  if (el) el.textContent = msg;
  console.log('[STATUS]', msg);
}

function handleError(err, context) {
  console.error(`Ошибка в ${context}:`, err);
  updateStatus(`Ошибка: ${err && err.message ? err.message : err}`);
}

// ========== UI: динамически создаём контролы (если нужно) ==========
function ensureModeControls() {
  // если уже созданы — возвращаем
  let controls = document.getElementById('custom-controls');
  if (controls) return controls;

  // Найдём "шапку" — контейнер, где лежат symbol/timeframe/connect buttons
  // Ищем ближайший контейнер, содержащий элемент symbol-selector или connect-button
  const symbolContainer = document.getElementById('symbol-selector')?.closest('div')
                         || document.getElementById('connect-button')?.closest('div')
                         || document.querySelector('body');

  // Создаём controls блок
  controls = document.createElement('div');
  controls.id = 'custom-controls';
  controls.style.display = 'flex';
  controls.style.flexWrap = 'wrap';
  controls.style.alignItems = 'center';
  controls.style.gap = '8px';
  controls.style.margin = '6px 0'; // немного отступа

  // Режимы
  const modeLabel = document.createElement('label');
  modeLabel.textContent = 'Режим:';
  controls.appendChild(modeLabel);

  ['historical','realtime'].forEach(m => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'mode-button';
    btn.dataset.mode = m;
    btn.textContent = m === 'historical' ? 'Исторический' : 'Реальный';
    btn.style.padding = '6px 8px';
    btn.style.cursor = 'pointer';
    if (m === 'historical') btn.style.fontWeight = '700';
    btn.addEventListener('click', () => {
      document.querySelectorAll('.mode-button').forEach(b=> b.style.fontWeight='400');
      btn.style.fontWeight = '700';
      controls.dataset.mode = m;
    });
    controls.appendChild(btn);
  });

  // Таймфрейм кнопки
  const tfLabel = document.createElement('label');
  tfLabel.textContent = 'Таймфрейм:';
  controls.appendChild(tfLabel);

  const tfOptions = ['1m','5m','15m','1H','4H','1D'];
  tfOptions.forEach(tf => {
    const tbtn = document.createElement('button');
    tbtn.type = 'button';
    tbtn.className = 'tf-button';
    tbtn.dataset.tf = tf;
    tbtn.textContent = tf;
    tbtn.style.padding = '6px 8px';
    tbtn.style.cursor = 'pointer';
    tbtn.addEventListener('click', () => {
      document.querySelectorAll('.tf-button').forEach(b => b.style.fontWeight='400');
      tbtn.style.fontWeight='700';
      window.currentTimeframe = tf;
      console.log('[UI] timeframe set to', tf);
    });
    if (tf === window.currentTimeframe) tbtn.style.fontWeight='700';
    controls.appendChild(tbtn);
  });

  // Start/End inputs
  const startInput = document.createElement('input');
  startInput.type = 'datetime-local';
  startInput.id = 'start-datetime';
  startInput.style.padding = '4px';
  startInput.title = 'Start (local)';
  controls.appendChild(startInput);

  const endInput = document.createElement('input');
  endInput.type = 'datetime-local';
  endInput.id = 'end-datetime';
  endInput.style.padding = '4px';
  endInput.title = 'End (local)';
  controls.appendChild(endInput);

  // Poll checkbox (realtime)
  const pollLabel = document.createElement('label');
  pollLabel.style.display = 'flex';
  pollLabel.style.alignItems = 'center';
  pollLabel.style.gap = '6px';
  const pollCheckbox = document.createElement('input');
  pollCheckbox.type = 'checkbox';
  pollCheckbox.id = 'realtime-poll';
  pollCheckbox.checked = true;
  const pollText = document.createElement('span');
  pollText.textContent = '1s update';
  pollLabel.appendChild(pollCheckbox);
  pollLabel.appendChild(pollText);
  controls.appendChild(pollLabel);

  // Вставляем controls в header (в начало найденного контейнера)
  try {
    // Если есть symbol container — вставляем сразу после него (в шапку)
    if (symbolContainer && symbolContainer.parentElement) {
      // Вставим controls сразу после symbolContainer
      symbolContainer.parentElement.insertBefore(controls, symbolContainer.nextSibling);
    } else {
      // fallback: вставить перед графиком
      const chartParent = document.getElementById('chart')?.parentElement || document.body;
      chartParent.insertBefore(controls, document.getElementById('chart'));
    }
  } catch (e) {
    // fallback
    document.body.insertBefore(controls, document.body.firstChild);
  }

  return controls;
}


// ========== Charts init (unchanged behavior) ==========
function initCharts(ohlcData, volumeData) {
  const chartElement = document.getElementById('chart');
  const volumeElement = document.getElementById('volume-chart');
  if (!chartElement || !volumeElement) { console.error('Элементы графиков не найдены'); return null; }
  chartElement.innerHTML = ''; volumeElement.innerHTML = '';
  if (typeof LightweightCharts === 'undefined') { console.error('LightweightCharts не загружена'); return null; }

  try {
    const rectChart = chartElement.getBoundingClientRect();
    const rectVol = volumeElement.getBoundingClientRect();
    const chartWidth = Math.max(1, Math.floor(rectChart.width || chartElement.clientWidth || 800));
    const chartHeight = Math.max(200, Math.floor(rectChart.height || 400));
    const volHeight = Math.max(100, Math.floor(rectVol.height || 150));

    const chart = LightweightCharts.createChart(chartElement, {
      width: chartWidth, height: chartHeight,
      layout: { background: { color: '#ffffff' }, textColor: '#333333' },
      grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
      timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#D1D4DC' },
      crosshair: { mode: LightweightCharts.CrosshairMode.Normal }
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350'
    });
    candleSeries.setData(ohlcData || []);

    const volumeChart = LightweightCharts.createChart(volumeElement, {
      width: chartWidth, height: volHeight,
      layout: { background: { color: '#ffffff' }, textColor: '#333333' },
      grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
      timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#D1D4DC' }
    });

    const volumeSeries = volumeChart.addHistogramSeries({
      priceFormat: { type: 'volume' }, priceScaleId: '', scaleMargins: { top: 0.85, bottom: 0 }
    });
    volumeSeries.setData(volumeData || []);

    if (window._timeRangeUnsub && typeof window._timeRangeUnsub === 'function') { try { window._timeRangeUnsub(); } catch (e){} window._timeRangeUnsub=null; }

    const unsubA = chart.timeScale().subscribeVisibleTimeRangeChange(range => { try { volumeChart.timeScale().setVisibleRange(range); } catch(e){} });
    const unsubB = volumeChart.timeScale().subscribeVisibleTimeRangeChange(range => { try { chart.timeScale().setVisibleRange(range); } catch(e){} });
    window._timeRangeUnsub = () => {
      try { chart.timeScale().unsubscribeVisibleTimeRangeChange(unsubA); } catch (e) {}
      try { volumeChart.timeScale().unsubscribeVisibleTimeRangeChange(unsubB); } catch (e) {}
    };

    if (window._resizeObserver) { try { window._resizeObserver.disconnect(); } catch (e) {} window._resizeObserver = null; }
    window._resizeObserver = new ResizeObserver(entries => {
      for (const entry of entries) {
        const w = Math.max(1, Math.floor(entry.contentRect.width || chartElement.clientWidth));
        const hChart = Math.max(200, Math.floor(document.getElementById('chart').getBoundingClientRect().height || 400));
        const hVol = Math.max(100, Math.floor(document.getElementById('volume-chart').getBoundingClientRect().height || 150));
        try { chart.resize(w, hChart); volumeChart.resize(w, hVol); } catch (e) {}
      }
    });
    const parent = chartElement.parentElement || chartElement;
    try { window._resizeObserver.observe(parent); } catch (e) {}

    try { chart.timeScale().scrollToRealTime(); } catch (e) {}

    return { chart, volumeChart, candleSeries, volumeSeries };
  } catch (error) {
    console.error('Ошибка при создании графиков:', error);
    return null;
  }
}

// ========== REST helper to fetch historical data (and optionally filter by period) ==========
function fetchHistorical(symbol, timeframe) {
  const prefix = getDashRequestsPathnamePrefix();
  const base = prefix === '/' ? '' : prefix;
  const apiUrl = `${base}/api/historical-data/${encodeURIComponent(symbol)}/${encodeURIComponent(timeframe)}`;
  console.log('[fetch] apiUrl =', apiUrl);
  return fetch(apiUrl).then(response => {
    console.log('[fetch] status:', response.status, 'content-type:', response.headers.get('content-type'));
    if (!response.ok) return response.text().then(t => { throw new Error(`HTTP ${response.status} - ${t}`); });
    const ct = (response.headers.get('content-type') || '').toLowerCase();
    if (!ct.includes('application/json')) return response.text().then(t => { console.error('[fetch] Non-JSON response body:', t); throw new Error('Non-JSON response'); });
    return response.json();
  });
}

// ========== WebSocket connection logic (business/public endpoint switching) ==========
function connectWebSocket(symbol, timeframe, candleSeries, volumeSeries) {
  // cleanup previous
  stopRealtimeInterval();
  if (window.ws) {
    try { window.ws.onopen = window.ws.onmessage = window.ws.onerror = window.ws.onclose = null; window.ws.close(); } catch(e){}
    window.ws = null; window.isConnected = false;
  }

  if (!symbol || !timeframe) { updateStatus('Не задан символ или таймфрейм'); return; }

  const wsUrls = [
    "wss://ws.okx.com:8443/ws/v5/business",
    "wss://wsaws.okx.com:8443/ws/v5/business",
    "wss://wspap.okx.com:8443/ws/v5/business",
    "wss://ws.okx.com:8443/ws/v5/public",
    "wss://wsaws.okx.com:8443/ws/v5/public",
    "wss://wspap.okx.com:8443/ws/v5/public"
  ];

  let currentIndex = 0;
  let reconnectAttempts = 0;

  function scheduleReconnect() {
    if (window._reconnectTimer) { clearTimeout(window._reconnectTimer); window._reconnectTimer = null; }
    const backoff = Math.min(60000, 1000 * Math.pow(2, Math.min(reconnectAttempts, 6)));
    const jitter = Math.floor(Math.random() * 500);
    const delay = backoff + jitter;
    console.log(`[WS] планируем reconnect через ${delay}ms (attempt ${reconnectAttempts})`);
    window._reconnectTimer = setTimeout(() => { reconnectAttempts++; doConnect(); }, delay);
  }

  function doConnect() {
    if (currentIndex >= wsUrls.length) { currentIndex = 0; reconnectAttempts++; }
    const wsUrl = wsUrls[currentIndex];
    console.log(`[WS] Попытка подключения: ${wsUrl}`);
    updateStatus(`Подключение к ${wsUrl}...`);

    try {
      window.ws = new WebSocket(wsUrl);

      window.ws.onopen = function() {
        console.log('[WS] open', wsUrl);
        window.isConnected = true; reconnectAttempts = 0;
        updateStatus(`Подключено к ${symbol} (${timeframe})`);

        const bar = mapTimeframeToOkxBar(timeframe);
        const channel = `candle${bar}`;
        const subscribeArg = { channel: channel, instId: symbol };

        if (wsUrl.includes('/business')) {
          subscribeArg.instType = 'SPOT';
        }

        // OKX expects {op:"subscribe", args:[{...}]}
        const subscribeMessage = { op: "subscribe", args: [ subscribeArg ] };

        try {
          window.ws.send(JSON.stringify(subscribeMessage));
          console.log('[WS] отправлен subscribe:', subscribeMessage);
        } catch (e) { console.error('[WS] не удалось отправить subscribe', e); }
      };

      window.ws.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          if (data.event === 'subscribe' || data.event === 'error') {
            console.log('[WS] subscribe response:', data);
            if (data.event === 'error') {
              console.error('[WS] subscribe error:', data);
              const msg = (data.msg || '').toLowerCase();
              if (msg.includes('wrong url') || msg.includes('wrong channel') || msg.includes('parameter') || (data.code && String(data.code).startsWith('6'))) {
                console.warn('[WS] Ошибка подписки указывает на некорректный endpoint/channel/params — переключаемся');
                try { window.ws.close(); } catch (e) {}
                currentIndex++; scheduleReconnect();
              }
            }
            return;
          }

          if (data.data && Array.isArray(data.data)) {
            data.data.forEach(candle => {
              const rawTs = candle[0];
              const timestamp = Math.floor(parseInt(rawTs) / 1000);
              const open = parseFloat(candle[1]); const high = parseFloat(candle[2]);
              const low = parseFloat(candle[3]); const close = parseFloat(candle[4]);
              const volume = parseFloat(candle[5]);
              if (candleSeries && volumeSeries) {
                try {
                  candleSeries.update({ time: timestamp, open, high, low, close });
                  volumeSeries.update({ time: timestamp, value: volume, color: close >= open ? 'rgba(38,166,154,0.5)' : 'rgba(239,83,80,0.5)' });
                } catch (err) { console.error('[WS] update series error:', err); }
              }
            });
          }
        } catch (error) {
          console.error('[WS] Ошибка обработки сообщения:', error, event && event.data);
        }
      };

      window.ws.onerror = function(err) {
        console.error('[WS] onerror', err);
        currentIndex++; scheduleReconnect();
      };

      window.ws.onclose = function(ev) {
        console.log('[WS] onclose', ev && ev.code, ev && ev.reason);
        window.isConnected = false;
        updateStatus('Отключено');
        currentIndex++; scheduleReconnect();
      };
    } catch (error) {
      console.error('[WS] Ошибка создания WebSocket:', error);
      currentIndex++; scheduleReconnect();
    }
  }

  doConnect();
}

// Stop realtime polling interval
function stopRealtimeInterval() {
  if (window._realtimeInterval) {
    clearInterval(window._realtimeInterval);
    window._realtimeInterval = null;
  }
}

// Start realtime polling: every second fetch latest candle and update last bar
function startRealtimePolling(symbol, timeframe, candleSeries, volumeSeries, enabled=true) {
  stopRealtimeInterval();
  if (!enabled) return;
  // Poll every second
  window._realtimeInterval = setInterval(() => {
    // get last candle via same historical endpoint then use last element
    fetchHistorical(symbol, timeframe)
      .then(data => {
        if (data && Array.isArray(data.ohlc) && data.ohlc.length > 0) {
          const last = data.ohlc[data.ohlc.length - 1];
          try {
            candleSeries.update({
              time: last.time,
              open: last.open,
              high: last.high,
              low: last.low,
              close: last.close
            });
            const vol = data.volume[data.volume.length - 1];
            volumeSeries.update({
              time: vol.time,
              value: vol.value,
              color: vol.color
            });
          } catch (e) { /* ignore update errors */ }
        }
      })
      .catch(err => {
        // silent: occasional polling failures OK (rate limits)
        console.debug('[poll] fetch latest failed', err && err.message);
      });
  }, 1000);
}

// Cleanly disconnect WS + intervals
function disconnectWebSocket() {
  if (window.ws) {
    try { window.ws.close(); } catch (e) {}
    window.ws = null;
  }
  stopRealtimeInterval();
  window.isConnected = false;
  updateStatus('Отключено');
  if (window._reconnectTimer) { clearTimeout(window._reconnectTimer); window._reconnectTimer = null; }
}

// ========== App init + wiring to UI ==========
function initializeApp() {
  try {
    // ensure custom controls present
    const ctrls = ensureModeControls();

    const check = setInterval(() => {
      const connectButton = document.getElementById('connect-button');
      const disconnectButton = document.getElementById('disconnect-button');
      const symbolSelector = document.getElementById('symbol-selector');
      const timeframeSelector = document.getElementById('timeframe-selector');

      // Скрываем dropdown timeframe (оставляем селектор монеты)
        if (timeframeSelector) {
            timeframeSelector.style.display = 'none';
        }

      if (connectButton && disconnectButton && symbolSelector && timeframeSelector && ctrls) {
        clearInterval(check);

        // initial read
        const sVal = readDropdownValue(symbolSelector) || 'BTC-USDT';
        const tVal = readDropdownValue(timeframeSelector) || '1H';
        window.currentSymbol = sVal;
        window.currentTimeframe = normalizeTimeframe(tVal);

        // keep timeframe buttons in sync
        document.querySelectorAll('.tf-button').forEach(b => {
          if (b.dataset.tf === window.currentTimeframe) b.style.fontWeight = '700'; else b.style.fontWeight='400';
        });

        // ensure start/end defaults (last 24h for start)
        const startInput = document.getElementById('start-datetime');
        const endInput = document.getElementById('end-datetime');
        if (startInput && endInput) {
          const now = new Date();
          const earlier = new Date(now.getTime() - 24*60*60*1000);
          if (!startInput.value) startInput.value = earlier.toISOString().slice(0,16);
          if (!endInput.value) endInput.value = now.toISOString().slice(0,16);
        }

        connectButton.addEventListener('click', () => {
          if (window.isConnected) { updateStatus('Уже подключено'); return; }
          // read current UI values
          const rawSym = readDropdownValue(symbolSelector) || window.currentSymbol;
          const rawTf = readDropdownValue(timeframeSelector) || window.currentTimeframe;
          const normalizedSymbol = normalizeSymbol(rawSym);
          const normalizedTf = normalizeTimeframe(window.currentTimeframe || rawTf);

          // mode
          const activeMode = ctrls.dataset.mode || 'historical';
          updateStatus('Загрузка исторических данных...');

          // fetch historical first to seed chart
          fetchHistorical(normalizedSymbol, normalizedTf)
            .then(data => {
              if (data.error) { handleError(data.error, 'загрузка исторических данных'); return; }
              // optionally filter by start/end if historical mode
              let ohlc = data.ohlc || [];
              let volume = data.volume || [];

              if (activeMode === 'historical') {
                const st = document.getElementById('start-datetime')?.value;
                const en = document.getElementById('end-datetime')?.value;
                if (st) {
                  const startTs = Math.floor(new Date(st).getTime()/1000);
                  ohlc = ohlc.filter(c => c.time >= startTs);
                  volume = volume.filter(v => v.time >= startTs);
                }
                if (en) {
                  const endTs = Math.floor(new Date(en).getTime()/1000);
                  ohlc = ohlc.filter(c => c.time <= endTs);
                  volume = volume.filter(v => v.time <= endTs);
                }
              }

              // init charts with filtered/seed data
              window.charts = initCharts(ohlc, volume);
              if (!window.charts) { updateStatus('Ошибка инициализации графиков'); return; }

              // For historical mode: no WS subscription by default (unless user also wants live)
              if (activeMode === 'historical') {
                updateStatus(`Отображается исторический период (${normalizedSymbol} ${normalizedTf})`);
                // done
                return;
              }

              // For realtime: connect WebSocket AND start polling if checkbox checked
              if (activeMode === 'realtime') {
                // websocket will push candles; additionally start per-second polling if enabled
                connectWebSocket(normalizedSymbol, normalizedTf, window.charts.candleSeries, window.charts.volumeSeries);
                const doPoll = document.getElementById('realtime-poll')?.checked ?? true;
                startRealtimePolling(normalizedSymbol, normalizedTf, window.charts.candleSeries, window.charts.volumeSeries, doPoll);
                return;
              }
            })
            .catch(err => { handleError(err, 'загрузка исторических данных'); });
        });

        disconnectButton.addEventListener('click', () => {
          disconnectWebSocket();
        });

        // Keep currentSymbol/timeframe in sync when dropdowns change (fallback reading)
        const updateSelectValues = () => {
          const s = readDropdownValue(symbolSelector);
          const tf = readDropdownValue(timeframeSelector);
          if (s) window.currentSymbol = s;
          if (tf) window.currentTimeframe = normalizeTimeframe(tf);
          console.log('Обновление значений:', { symbol: window.currentSymbol, timeframe: window.currentTimeframe });
        };
        const observer = new MutationObserver(updateSelectValues);
        observer.observe(symbolSelector, { childList: true, subtree: true, attributes: true });
        observer.observe(timeframeSelector, { childList: true, subtree: true, attributes: true });
        symbolSelector.addEventListener('click', updateSelectValues);
        timeframeSelector.addEventListener('click', updateSelectValues);
      }
    }, 100);
  } catch (error) {
    handleError(error, 'инициализация приложения');
  }
}

// ========== Startup ==========
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  initializeApp();
}

# === file: app.py ===

import logging
import requests
import json
import pandas as pd

from flask import Flask, jsonify, request
import dash
from dash import dcc, html, Input, Output

# Логирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# создаём Flask server первым
server = Flask(__name__)

# --- Регистрируем API роуты на Flask до инициализации Dash ---
AVAILABLE_SYMBOLS = [
    {'label': 'BTC/USDT', 'value': 'BTC-USDT'},
    {'label': 'ETH/USDT', 'value': 'ETH-USDT'},
    {'label': 'OKB/USDT', 'value': 'OKB-USDT'},
    {'label': 'SOL/USDT', 'value': 'SOL-USDT'},
    {'label': 'DOT/USDT', 'value': 'DOT-USDT'},
    {'label': 'XRP/USDT', 'value': 'XRP-USDT'},
    {'label': 'ADA/USDT', 'value': 'ADA-USDT'},
    {'label': 'DOGE/USDT', 'value': 'DOGE-USDT'},
    {'label': 'LTC/USDT', 'value': 'LTC-USDT'},
    {'label': 'AVAX/USDT', 'value': 'AVAX-USDT'}
]

@server.route('/api/historical-data/<symbol>/<timeframe>', methods=['GET'])
def get_historical_data(symbol, timeframe):
    logger.info(f"[API] request /api/historical-data symbol={symbol}, timeframe={timeframe}, from={request.remote_addr}")
    try:
        if not any(s['value'] == symbol for s in AVAILABLE_SYMBOLS):
            logger.warning(f"[API] Недоступный символ: {symbol}")
            return jsonify({'error': f'Символ {symbol} недоступен'}), 400

        timeframe_map = {
            '1m': '1m', '5m': '5m', '15m': '15m',
            '1H': '1H', '4H': '4H', '1D': '1D'
        }
        okx_timeframe = timeframe_map.get(timeframe, '1H')

        url = "https://www.okx.com/api/v5/market/history-candles"
        params = {
            'instId': symbol,
            'bar': okx_timeframe,
            'limit': 100
        }
        logger.info(f"[API] Запрос исторических данных OKX: {params}")
        resp = requests.get(url, params=params, timeout=10)
        resp.raise_for_status()
        data = resp.json()

        if data.get('code') != '0':
            error_msg = data.get('msg', 'Unknown error from OKX API')
            logger.error(f"[API] OKX returned error: {error_msg}")
            return jsonify({'error': error_msg}), 502

        ohlc_list = []
        volume_list = []
        for candle in data['data']:
            timestamp = int(candle[0]) // 1000
            open_price = float(candle[1])
            high_price = float(candle[2])
            low_price = float(candle[3])
            close_price = float(candle[4])
            vol = float(candle[5])

            ohlc_list.append({
                'time': timestamp,
                'open': open_price,
                'high': high_price,
                'low': low_price,
                'close': close_price
            })
            volume_list.append({
                'time': timestamp,
                'value': vol,
                'color': 'rgba(38, 166, 154, 0.5)' if close_price > open_price else 'rgba(239, 83, 80, 0.5)'
            })

        ohlc_list.reverse()
        volume_list.reverse()

        logger.info(f"[API] Возвращено {len(ohlc_list)} свечей для {symbol}")
        return jsonify({'ohlc': ohlc_list, 'volume': volume_list}), 200

    except Exception as e:
        logger.exception("[API] Ошибка при получении исторических данных")
        return jsonify({'error': str(e)}), 500

# --- Теперь инициализируем Dash, используя тот же Flask server ---
app = dash.Dash(__name__, server=server, external_scripts=[
    "https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"
])

app.layout = html.Div([
    html.H1("Real-time OKX Market Data"),
    html.Div([
        html.Label('Выберите символ:'),
        dcc.Dropdown(
            id='symbol-selector',
            options=AVAILABLE_SYMBOLS,
            value='BTC-USDT',
            style={'width': '200px', 'margin': '10px'}
        ),
        html.Label('Таймфрейм:'),
        dcc.Dropdown(
            id='timeframe-selector',
            options=[
                {'label': '1 минута', 'value': '1m'},
                {'label': '5 минут', 'value': '5m'},
                {'label': '15 минут', 'value': '15m'},
                {'label': '1 час', 'value': '1H'},
                {'label': '4 часа', 'value': '4H'},
                {'label': '1 день', 'value': '1D'}
            ],
            value='1H',
            style={'width': '200px', 'margin': '10px'}
        ),
        html.Button('Подключиться', id='connect-button', n_clicks=0),
        html.Button('Отключиться', id='disconnect-button', n_clicks=0),
    ], style={'display': 'flex', 'alignItems': 'center', 'margin': '10px'}),
    html.Div(id='status', style={'margin': '10px', 'fontWeight': 'bold'}),
    html.Div([
        html.Div(id='chart', style={'height': '500px', 'width': '100%'}),
        html.Div(id='volume-chart', style={'height': '150px', 'width': '100%', 'marginTop': '20px'}),
    ]),
    dcc.Store(id='historical-data'),
    dcc.Store(id='ws-connection-status', data={'connected': False}),
])

@app.callback(
    [Output('status', 'children'),
     Output('historical-data', 'data'),
     Output('ws-connection-status', 'data')],
    [Input('connect-button', 'n_clicks'),
     Input('disconnect-button', 'n_clicks')],
    [dash.dependencies.State('symbol-selector', 'value'),
     dash.dependencies.State('timeframe-selector', 'value'),
     dash.dependencies.State('ws-connection-status', 'data')]
)
def manage_connection(connect_clicks, disconnect_clicks, symbol, timeframe, ws_status):
    ctx = dash.callback_context
    if not ctx.triggered:
        return "Нажмите 'Подключиться' для начала", dash.no_update, dash.no_update

    trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    if trigger_id == 'connect-button' and connect_clicks > 0:
        if not ws_status.get('connected', False):
            try:
                response = requests.get(f'http://127.0.0.1:8050/api/historical-data/{symbol}/{timeframe}', timeout=10)
                data = response.json()

                if 'error' in data:
                    return f"Ошибка: {data['error']}", dash.no_update, dash.no_update

                return f"Подключение к {symbol} ({timeframe})...", data, {'connected': True, 'symbol': symbol, 'timeframe': timeframe}
            except Exception as e:
                return f"Ошибка подключения: {str(e)}", dash.no_update, dash.no_update

    elif trigger_id == 'disconnect-button' and disconnect_clicks > 0:
        return "Отключено", dash.no_update, {'connected': False}

    return dash.no_update, dash.no_update, dash.no_update

if __name__ == '__main__':
    app.run(debug=True, host='127.0.0.1', port=8050)
